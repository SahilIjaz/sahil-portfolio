# Code Refactoring Rules

These rules guide how Claude Code should refactor your code automatically.

---

## üéØ Primary Goals

When refactoring, prioritize these objectives:

1. **Readability** - Make code easier to understand
2. **Maintainability** - Simplify future changes
3. **Type Safety** - Add proper TypeScript types
4. **Performance** - Optimize where it matters
5. **Consistency** - Follow established patterns

---

## üìè Code Style Guidelines

### General Principles
- Use descriptive, intention-revealing names
- Keep functions focused (single responsibility)
- Prefer composition over inheritance
- Avoid deep nesting (max 3 levels)
- Add comments only when necessary (code should be self-documenting)

### Naming Conventions
- **Variables**: `camelCase` - descriptive nouns (e.g., `userData`, `isLoading`)
- **Functions**: `camelCase` - verb + noun (e.g., `fetchUserData`, `handleClick`)
- **Components**: `PascalCase` - nouns (e.g., `UserProfile`, `NavigationBar`)
- **Constants**: `UPPER_SNAKE_CASE` - (e.g., `MAX_RETRY_COUNT`, `API_BASE_URL`)
- **Types/Interfaces**: `PascalCase` - (e.g., `UserData`, `ApiResponse`)

### Code Organization
- Max function length: 50 lines
- Max file length: 300 lines (extract when exceeded)
- Group related functions together
- Keep imports organized (external ‚Üí internal ‚Üí types)

---

## üî∑ TypeScript Specific Rules

### Type Safety
```typescript
// ‚úÖ Good - Explicit types
function calculateTotal(items: CartItem[]): number {
  return items.reduce((sum, item) => sum + item.price, 0);
}

// ‚ùå Bad - Implicit any
function calculateTotal(items) {
  return items.reduce((sum, item) => sum + item.price, 0);
}
```

### Guidelines
- **Always** add explicit return types to functions
- **Avoid** using `any` - use `unknown` if type is truly unknown
- **Prefer** interfaces over type aliases for objects
- **Use** utility types (`Partial`, `Pick`, `Omit`, etc.)
- **Enable** strict mode in tsconfig.json

---

## ‚öõÔ∏è React/Next.js Specific Rules

### Component Structure
```tsx
// ‚úÖ Good - Clean, typed component
interface UserCardProps {
  user: User;
  onSelect: (id: string) => void;
}

export function UserCard({ user, onSelect }: UserCardProps) {
  return (
    <div onClick={() => onSelect(user.id)}>
      <h3>{user.name}</h3>
      <p>{user.email}</p>
    </div>
  );
}

// ‚ùå Bad - Untyped, inline everything
export function UserCard(props) {
  return (
    <div onClick={() => props.onSelect(props.user.id)}>
      <h3>{props.user.name}</h3>
      <p>{props.user.email}</p>
    </div>
  );
}
```

### Component Guidelines
- **Extract components** when JSX exceeds 50 lines
- **Use custom hooks** for reusable stateful logic
- **Prefer** functional components over class components
- **Memoize** expensive computations with `useMemo`
- **Memoize** callback functions with `useCallback`
- **Add** prop types for all components
- **Use** semantic HTML elements

### State Management
- Keep state as local as possible
- Lift state only when necessary
- Use `useState` for simple state
- Use `useReducer` for complex state
- Avoid prop drilling (use context or composition)

---

## üé® Styling Rules (Tailwind CSS)

### Class Organization
```tsx
// ‚úÖ Good - Organized, readable
<div className="flex flex-col gap-4 rounded-lg bg-white p-6 shadow-md dark:bg-gray-800">
  {/* content */}
</div>

// ‚ùå Bad - Random order, hard to read
<div className="p-6 shadow-md bg-white flex gap-4 rounded-lg dark:bg-gray-800 flex-col">
  {/* content */}
</div>
```

### Guidelines
- Group classes: layout ‚Üí spacing ‚Üí sizing ‚Üí colors ‚Üí effects
- Extract repeated class combinations to components
- Use Tailwind's responsive prefixes consistently
- Prefer Tailwind utilities over custom CSS

---

## üöÄ Performance Optimization

### When to Optimize
- **Extract** repeated code into reusable functions
- **Memoize** expensive calculations
- **Lazy load** large components
- **Debounce** rapid user inputs
- **Virtualize** long lists

### What to Avoid
- Premature optimization
- Micro-optimizations that hurt readability
- Over-engineering simple features

---

## ‚úÖ Best Practices

### Error Handling
```typescript
// ‚úÖ Good - Proper error handling
async function fetchUserData(id: string): Promise<User> {
  try {
    const response = await fetch(`/api/users/${id}`);

    if (!response.ok) {
      throw new Error(`Failed to fetch user: ${response.statusText}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Error fetching user:', error);
    throw error;
  }
}

// ‚ùå Bad - Silent failures
async function fetchUserData(id) {
  const response = await fetch(`/api/users/${id}`);
  return await response.json();
}
```

### Async/Await
- **Prefer** async/await over raw promises
- **Always** handle errors in async functions
- **Avoid** mixing .then() and async/await

### Code Duplication
- **DRY Principle**: Extract repeated logic
- **Create utilities** for common operations
- **Share types** across related files

---

## üö´ What NOT to Change

### Preserve Functionality
- ‚ùå **Never** change the behavior of existing functions
- ‚ùå **Never** remove or rename exported functions (breaks imports)
- ‚ùå **Never** change API contracts
- ‚ùå **Never** modify database schemas

### Preserve Comments
- ‚úÖ **Keep** meaningful comments explaining "why"
- ‚úÖ **Keep** TODO comments
- ‚úÖ **Keep** warning/caution comments
- ‚ùå **Remove** obvious comments that just repeat code

---

## üéØ Refactoring Priorities

### High Priority (Always Do)
1. Add missing TypeScript types
2. Fix obvious bugs or potential errors
3. Extract large functions (>50 lines)
4. Remove code duplication
5. Improve unclear variable names

### Medium Priority (When Appropriate)
1. Optimize performance bottlenecks
2. Simplify complex conditionals
3. Extract reusable components
4. Improve error handling
5. Add helpful comments

### Low Priority (Nice to Have)
1. Consistent formatting
2. Alphabetize imports
3. Organize code structure
4. Minor optimizations

---

## üìã Refactoring Checklist

Before marking a file as "refactored", ensure:

- [ ] All functions have explicit return types
- [ ] No `any` types (unless absolutely necessary)
- [ ] Function length < 50 lines
- [ ] Descriptive variable and function names
- [ ] No obvious code duplication
- [ ] Proper error handling in async functions
- [ ] Components have typed props
- [ ] Complex logic is commented
- [ ] Code follows project conventions
- [ ] All functionality still works (no breaking changes)

---

## üåü Example Refactoring

### Before
```typescript
function getData(id) {
  return fetch('/api/data/' + id).then(r => r.json()).catch(e => console.log(e));
}

export default function Card(props) {
  const [data, setData] = useState();

  useEffect(() => {
    getData(props.id).then(d => setData(d));
  }, [props.id]);

  return <div>{data && data.name}</div>;
}
```

### After
```typescript
interface DataResponse {
  id: string;
  name: string;
  description: string;
}

async function fetchData(id: string): Promise<DataResponse> {
  try {
    const response = await fetch(`/api/data/${id}`);

    if (!response.ok) {
      throw new Error(`Failed to fetch data: ${response.statusText}`);
    }

    return await response.json();
  } catch (error) {
    console.error('Error fetching data:', error);
    throw error;
  }
}

interface CardProps {
  id: string;
}

export default function Card({ id }: CardProps) {
  const [data, setData] = useState<DataResponse | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    let isMounted = true;

    async function loadData() {
      setIsLoading(true);
      setError(null);

      try {
        const result = await fetchData(id);
        if (isMounted) {
          setData(result);
        }
      } catch (err) {
        if (isMounted) {
          setError(err as Error);
        }
      } finally {
        if (isMounted) {
          setIsLoading(false);
        }
      }
    }

    loadData();

    return () => {
      isMounted = false;
    };
  }, [id]);

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;
  if (!data) return null;

  return (
    <div className="rounded-lg bg-white p-4 shadow">
      <h3 className="text-lg font-semibold">{data.name}</h3>
      <p className="text-gray-600">{data.description}</p>
    </div>
  );
}
```

**Changes Made:**
- ‚úÖ Added TypeScript types (`DataResponse`, `CardProps`)
- ‚úÖ Converted to async/await
- ‚úÖ Added proper error handling
- ‚úÖ Added loading and error states
- ‚úÖ Fixed memory leak (cleanup in useEffect)
- ‚úÖ Improved naming (`getData` ‚Üí `fetchData`)
- ‚úÖ Added Tailwind classes for styling
- ‚úÖ Better null checking

---

## üí° Tips for Customization

**To customize these rules for your project:**

1. **Add language-specific rules** (Python, Go, etc.)
2. **Specify your preferred libraries** (Zustand, React Query, etc.)
3. **Define project-specific patterns** (API client usage, auth patterns, etc.)
4. **Add team conventions** (PR review checklist, commit message format, etc.)
5. **Set complexity limits** (cyclomatic complexity, nesting depth, etc.)

**This file is YOUR guide** - edit it to match your style!

---

**Last Updated:** 2025-11-12
**Project:** Sahil Portfolio (but works for any project!)
